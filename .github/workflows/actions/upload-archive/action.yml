name: 'Upload Artifacts with Caching'
description: 'Uploads compressed artifacts and saves them to GitHub cache (90-day retention)'

inputs:
  name:
    description: 'Artifact name'
    required: true
  output:
    description: 'Output filename (with .zip extension)'
    required: true
  paths:
    description: 'Artifact paths (can be a pattern or directory)'
    required: true
  retention_days:
    description: 'Retention days for GitHub artifacts'
    required: false
    default: '90'
  cache_key_prefix:
    description: 'Prefix for the cache key'
    default: 'build-artifacts'
    required: false

outputs:
  size:
    description: 'Size of the upload in bytes'
    value: ${{ steps.compress.outputs.size }}
  cache_key:
    description: 'The cache key used for the upload, can be passed to download-archive as exact_cache_key'
    value: ${{ steps.generate-keys.outputs.standard_key }}

runs:
  using: 'composite'
  steps:
    # Check for rerun attempts and handle them specially
    - name: ü™Ñ Check for Rerun Attempt
      id: check-rerun
      shell: bash
      run: |
        # Check if this is a rerun of a previous workflow run
        RUN_ATTEMPT="${{ github.run_attempt }}"

        if [[ "${RUN_ATTEMPT}" -gt 1 ]]; then
          # This is a rerun, add a suffix to avoid conflicts
          RERUN_SUFFIX="-rerun${RUN_ATTEMPT}"
          echo "::notice::Rerun #${RUN_ATTEMPT} detected - using unique cache keys to avoid conflicts"
        else
          # Not a rerun, no suffix needed
          RERUN_SUFFIX=""
        fi

        echo "rerun_suffix=${RERUN_SUFFIX}" >> $GITHUB_OUTPUT

    # Compress the specified directories/files into a .zip file
    - name: üóúÔ∏è Compress Files (Unix)
      if: runner.os != 'Windows'
      id: compress-unix
      shell: bash
      run: |
        # Create output directory
        mkdir -p $(dirname "${{ inputs.output }}")

        # Get file count before compression (for validation)
        FILE_COUNT=$(find ${{ inputs.paths }} -type f | wc -l)

        # Compress files (excluding node_modules by default)
        zip -r "${{ inputs.output }}" ${{ inputs.paths }} -x "*/node_modules/*" "*/\.*/*"

        # Get archive size for reporting
        FILE_SIZE=$(stat -c%s "${{ inputs.output }}" 2>/dev/null || stat -f%z "${{ inputs.output }}" 2>/dev/null || ls -l "${{ inputs.output }}" | awk '{print $5}')
        HUMAN_SIZE=$(du -h "${{ inputs.output }}" | cut -f1)

        # Display a concise summary of the archive
        echo "::notice::Artifact ${{ inputs.name }}: created ${HUMAN_SIZE} archive with ${FILE_COUNT} files"

        # Export artifact size
        echo "size=${FILE_SIZE}" >> $GITHUB_OUTPUT

    # Compress the specified directories/files into a .zip file (Windows)
    - name: üóúÔ∏è Compress Files (Windows)
      if: runner.os == 'Windows'
      id: compress-windows
      shell: powershell
      run: |
        # Create output directory
        $outputDir = Split-Path -Parent "${{ inputs.output }}"
        if (![string]::IsNullOrEmpty($outputDir)) {
          New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
        }

        # Get file count before compression (for validation)
        # Check if path exists first to avoid PowerShell errors with non-existent paths
        $paths = "${{ inputs.paths }}" -split ' '
        $fileCount = 0
        foreach ($path in $paths) {
          if (Test-Path $path) {
            $fileCount += (Get-ChildItem -Path $path -File -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch "node_modules" -and $_.FullName -notmatch "\\\..*\\|/\..*/" }).Count
          } else {
            Write-Host "::warning::Path does not exist (may be expected): $path"
          }
        }

        # Normalize file timestamps BEFORE compression (for Rust target directories)
        # ZIP format only supports dates between 1980-01-01 and 2107-12-31
        $validDate = Get-Date "2020-01-01"
        $minDate = Get-Date "1980-01-01"
        $maxDate = Get-Date "2107-12-31"

        foreach ($path in $paths) {
          if (Test-Path $path -ErrorAction SilentlyContinue) {
            # Normalize timestamps for both files and directories
            Get-ChildItem -Path $path -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              try {
                # Normalize all three timestamp properties
                if ($_.LastWriteTime -lt $minDate -or $_.LastWriteTime -gt $maxDate) {
                  $_.LastWriteTime = $validDate
                }
                if ($_.CreationTime -lt $minDate -or $_.CreationTime -gt $maxDate) {
                  $_.CreationTime = $validDate
                }
                if ($_.LastAccessTime -lt $minDate -or $_.LastAccessTime -gt $maxDate) {
                  $_.LastAccessTime = $validDate
                }
              } catch {
                # If we can't set timestamps, log and skip
                Write-Host "::debug::Could not normalize timestamps for: $($_.FullName)"
              }
            }
          }
        }

        # Compress directories preserving structure using 7zip for cross-platform compatibility
        # 7zip creates ZIP files with forward slashes, avoiding Windows path separator issues
        try {
          if ($paths.Count -gt 0) {
            # Install 7zip if not available
            if (!(Get-Command "7z" -ErrorAction SilentlyContinue)) {
              Write-Host "Installing 7zip for cross-platform ZIP creation..."
              choco install 7zip -y --no-progress
            }

            # Use 7zip for cross-platform compatible ZIP creation
            $7zArgs = @("a", "-tzip", "${{ inputs.output }}")
            $7zArgs += $paths

            & 7z @7zArgs
            if ($LASTEXITCODE -ne 0) {
              throw "7zip failed with exit code $LASTEXITCODE"
            }
          } else {
            # Create empty archive if no paths found
            Compress-Archive -Path @() -DestinationPath "${{ inputs.output }}" -Force -ErrorAction Stop
          }
        } catch {
          Write-Host "::error::Failed to create archive: $_"
          Write-Host "::error::This may be due to file timestamps outside the ZIP format range (1980-2107)"

          # Try to find files with problematic timestamps
          Write-Host "Checking for files with invalid timestamps..."
          foreach ($path in $paths) {
            if (Test-Path $path -ErrorAction SilentlyContinue) {
              Get-ChildItem -Path $path -Recurse -ErrorAction SilentlyContinue | Where-Object {
                $_.LastWriteTime -lt $minDate -or $_.LastWriteTime -gt $maxDate -or
                $_.CreationTime -lt $minDate -or $_.CreationTime -gt $maxDate -or
                $_.LastAccessTime -lt $minDate -or $_.LastAccessTime -gt $maxDate
              } | ForEach-Object {
                Write-Host "::warning::Invalid timestamp on: $($_.FullName)"
                Write-Host "  LastWriteTime: $($_.LastWriteTime)"
                Write-Host "  CreationTime: $($_.CreationTime)"
                Write-Host "  LastAccessTime: $($_.LastAccessTime)"
              }
            }
          }

          throw
        }

        # Get archive size for reporting
        $fileSize = (Get-Item "${{ inputs.output }}").Length
        $humanSize = if ($fileSize -lt 1KB) { "$fileSize B" }
                    elseif ($fileSize -lt 1MB) { "{0:N1} KB" -f ($fileSize / 1KB) }
                    elseif ($fileSize -lt 1GB) { "{0:N1} MB" -f ($fileSize / 1MB) }
                    else { "{0:N1} GB" -f ($fileSize / 1GB) }

        # Display a concise summary of the archive
        Write-Host "::notice::Artifact ${{ inputs.name }}: created $humanSize archive with $fileCount files"

        # Export artifact size
        "size=$fileSize" >> $env:GITHUB_OUTPUT

    # Set outputs from the appropriate step
    - name: üîó Set Compression Outputs
      id: compress
      shell: bash
      run: |
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "size=${{ steps.compress-windows.outputs.size }}" >> $GITHUB_OUTPUT
        else
          echo "size=${{ steps.compress-unix.outputs.size }}" >> $GITHUB_OUTPUT
        fi

    # Generate cache keys
    - name: üîë Generate Cache Keys
      id: generate-keys
      shell: bash
      run: |
        # Ensure values have defaults
        CACHE_PREFIX="${{ inputs.cache_key_prefix || 'artifacts' }}"
        NAME="${{ inputs.name }}"
        OS="${{ runner.os }}"
        RUN_ID="${{ github.run_id }}"
        RERUN_SUFFIX="${{ steps.check-rerun.outputs.rerun_suffix }}"

        # Generate platform-specific key (no cross-platform sharing to avoid path issues)
        PLATFORM_KEY="${OS}-${CACHE_PREFIX}-${NAME}-${RUN_ID}${RERUN_SUFFIX}"
        echo "platform_key=${PLATFORM_KEY}" >> $GITHUB_OUTPUT

        # Keep standard key for backward compatibility
        STANDARD_KEY="${OS}-${CACHE_PREFIX}-${NAME}-${RUN_ID}${RERUN_SUFFIX}"
        echo "standard_key=${STANDARD_KEY}" >> $GITHUB_OUTPUT

        # Generate OS-agnostic key (used across platforms)
        AGNOSTIC_KEY="${CACHE_PREFIX}-${NAME}-${RUN_ID}${RERUN_SUFFIX}"
        echo "agnostic_key=${AGNOSTIC_KEY}" >> $GITHUB_OUTPUT

    # Upload to GitHub Artifacts
    - name: üì§ Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}
        path: ${{ inputs.output }}
        retention-days: ${{ inputs.retention_days }}
        if-no-files-found: error

    # Cache with platform-specific key
    # Cross-platform archive enabled - works for TypeScript packages (wdio-electron-build)
    # Tauri apps use 7zip for cross-platform compatible ZIPs
    - name: üóÑÔ∏è Cache Artifact (Platform-specific)
      uses: actions/cache/save@v4
      env:
        ACTIONS_CACHE_SERVICE_V2: 'true'
      with:
        path: ${{ inputs.output }}
        key: ${{ steps.generate-keys.outputs.platform_key }}
        enableCrossOsArchive: true
