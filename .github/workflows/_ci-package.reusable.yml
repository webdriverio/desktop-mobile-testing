name: Package
description: 'Runs package tests across different operating systems'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        type: string
        required: true
      service:
        description: 'Service to test (electron, tauri, or both)'
        type: string
        required: false
        default: 'both'
      module-type:
        description: 'Module type for Electron package tests (cjs, esm, or both)'
        type: string
        required: false
        default: 'both'
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading artifacts'
        type: string
        required: false
      tauri_cache_key:
        description: 'Cache key for Tauri package test app binaries'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1

jobs:
  # This job runs package tests on multiple Node.js versions and operating systems
  package:
    name: Package Tests - ${{ inputs.service == 'electron' && 'Electron' || inputs.service == 'tauri' && 'Tauri' || 'Both' }}
    runs-on: ${{ inputs.os }}
    steps:
      # Standard checkout with SSH key for private repositories
      - name: üë∑ Checkout Repository
        uses: actions/checkout@v5
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: '20'

      # Install Rust toolchain and tauri-driver if testing Tauri service
      - name: ü¶Ä Setup Rust (for tauri-driver)
        if: inputs.service == 'tauri' || inputs.service == 'both'
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: üöó Install tauri-driver
        if: inputs.service == 'tauri' || inputs.service == 'both'
        shell: bash
        run: |
          echo "Installing tauri-driver..."
          cargo install tauri-driver

      # Install WebKit WebDriver for Linux (required by tauri-driver)
      - name: üåê Install WebKit WebDriver (Linux)
        if: (inputs.service == 'tauri' || inputs.service == 'both') && runner.os == 'Linux'
        shell: bash
        run: |
          echo "Installing WebKit WebDriver for Linux..."
          sudo apt-get update
          sudo apt-get install -y webkit2gtk-driver
          # Verify installation
          which WebKitWebDriver || echo "WebKitWebDriver not found in PATH"
          WebKitWebDriver --version || echo "WebKitWebDriver version check failed"

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: üì¶ Download Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Download app binaries if testing services that require pre-built apps
      # The download-archive action extracts to workspace root, preserving directory structure
      # Tauri: Archive contains fixtures/package-tests/tauri-app/src-tauri/target
      # Electron: Apps are built in isolated environments by test-package.ts script
      - name: üì¶ Download Tauri Package Test App Binary
        if: inputs.service == 'tauri' || inputs.service == 'both'
        uses: ./.github/workflows/actions/download-archive
        with:
          name: tauri-package-app-${{ runner.os }}
          path: tauri-package-app-${{ runner.os }}
          filename: artifact.zip
          cache_key_prefix: tauri-package-app
          exact_cache_key: ${{ inputs.tauri_cache_key || '' }}

      # Verify the extracted dist directories exist
      - name: üîç Verify Extracted Files
        id: verify-build
        shell: bash
        run: |
          # Only output build info if it's available
          if [ -n "${{ inputs.build_id }}" ] && [ -n "${{ inputs.artifact_size }}" ]; then
            echo "::notice::Build artifact: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"
          fi

          # Check for distribution directories (minimal validation)
          DIST_DIRS=$(find "${{ github.workspace }}" -path "*/dist" -type d | wc -l)
          if [ "$DIST_DIRS" -lt 1 ]; then
            echo "::warning::No dist directories found, build extraction may have failed"
          fi

      # Pack services from downloaded artifacts so --skip-build can use them
      # This creates the .tgz files that the test script expects when --skip-build is used
      - name: üì¶ Pack Services from Artifacts
        shell: bash
        run: |
          echo "Packing services from downloaded artifacts..."
          # Pack shared dependencies
          if [ -d "packages/native-utils/dist" ]; then
            (cd packages/native-utils && pnpm pack)
          fi
          if [ -d "packages/native-types/dist" ]; then
            (cd packages/native-types && pnpm pack)
          fi

          # Pack Electron service and dependencies if needed
          if [ "${{ inputs.service }}" == "electron" ] || [ "${{ inputs.service }}" == "both" ]; then
            if [ -d "packages/electron-cdp-bridge/dist" ]; then
              (cd packages/electron-cdp-bridge && pnpm pack)
            fi
            if [ -d "packages/electron-service/dist" ]; then
              (cd packages/electron-service && pnpm pack)
            fi
          fi

          # Pack Tauri service if needed
          if [ "${{ inputs.service }}" == "tauri" ] || [ "${{ inputs.service }}" == "both" ]; then
            if [ -d "packages/tauri-service/dist" ]; then
              (cd packages/tauri-service && pnpm pack)
            fi
          fi

      # Run package tests using test-package.ts script
      # All apps are built in isolated environments (Electron always, Tauri if not skipBuild)
      # Tauri uses skipBuild to copy pre-built binaries from separate build jobs
      - name: üß™ Execute Package Tests
        shell: bash
        run: |
          case "${{ inputs.service }}" in
            electron)
              echo "Running Electron package tests (apps built in isolated environments)"
              echo "Module type: ${{ inputs.module-type }}"
              pnpm run test:package:electron -- --module-type=${{ inputs.module-type }}
              ;;
            tauri)
              if [ "${{ inputs.os }}" == "macos-latest" ]; then
                echo "‚ö†Ô∏è  Skipping Tauri package tests on macOS (not supported)"
                exit 0
              fi
              echo "Running Tauri package tests (using pre-built binaries from separate build job)"
              if [ "${{ inputs.os }}" == "ubuntu-latest" ]; then
                echo "Using xvfb-run to provide a DISPLAY on Linux"
                xvfb-run -a pnpm run test:package:tauri -- --skip-build
              else
                pnpm run test:package:tauri -- --skip-build
              fi
              ;;
            both)
              if [ "${{ inputs.os }}" == "macos-latest" ]; then
                echo "‚ö†Ô∏è  Skipping Tauri package tests on macOS (not supported)"
                echo "Module type: ${{ inputs.module-type }}"
                pnpm run test:package:electron -- --module-type=${{ inputs.module-type }}
              else
                echo "Running all package tests (Electron built in isolated environments, Tauri using pre-built binaries)"
                echo "Module type: ${{ inputs.module-type }}"
                # Electron: build in isolated environments (no --skip-build)
                pnpm run test:package:electron -- --module-type=${{ inputs.module-type }}
                # Tauri: use --skip-build for pre-built binaries from separate build job
                if [ "${{ inputs.os }}" == "ubuntu-latest" ]; then
                  xvfb-run -a pnpm run test:package:tauri -- --skip-build
                else
                  pnpm run test:package:tauri -- --skip-build
                fi
              fi
              ;;
            *)
              echo "Invalid service: ${{ inputs.service }}"
              exit 1
              ;;
          esac

      # Provide an interactive debugging session on failure
      # This allows manual investigation of the environment
      - name: üêõ Debug Build on Failure
        uses: goosewobbler/vscode-server-action@v1.3.0
        if: failure()
        with:
          timeout: '180000'
