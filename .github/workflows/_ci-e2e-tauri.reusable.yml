name: Tauri E2E Tests
description: 'Runs Tauri end-to-end tests across different scenarios and test types'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use for testing'
        required: true
        type: string
      build-command:
        description: 'Build command for test applications (build or build:mac-universal)'
        type: string
        default: 'build'
      scenario:
        description: 'Test scenario (tauri-basic)'
        required: true
        type: string
      test-type:
        description: 'Test type (standard, multiremote, standalone)'
        type: string
        default: 'standard'
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading package artifacts'
        type: string
        required: false
      tauri_cache_key:
        description: 'Cache key to use for downloading Tauri app binaries'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1
  TURBO_DAEMON: false

jobs:
  # This job runs Tauri E2E tests for a specific combination of:
  # - Operating system (Linux, Windows, macOS)
  # - Test scenario (tauri-basic)
  # - Test type (standard, multiremote, standalone)
  # Note: macOS tests are skipped due to WKWebView limitations
  e2e-tauri:
    name: Tauri E2E Tests
    runs-on: ${{ inputs.os }}
    # Skip Tauri E2E tests on macOS due to WKWebView WebDriver limitations
    if: inputs.os != 'macos-latest'
    strategy:
      # Continue with other tests even if one fails
      fail-fast: false
    steps:
      # Standard checkout with SSH key for private repositories
      - name: üë∑ Checkout Repository
        uses: actions/checkout@v5
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: üõ†Ô∏è Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: ${{ inputs.node-version }}

      # Install Tauri runtime dependencies on Linux (apps are pre-built, only need runtime libs)
      # Minimum requirements per Tauri docs: libwebkit2gtk-4.1-0, libgtk-3-0, libappindicator3-1
      # Additional libraries may be pulled in as transitive dependencies
      - name: ü¶Ä Install Tauri Runtime Dependencies (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "Installing Tauri runtime dependencies for Linux..."
          sudo tee -a /etc/apt/sources.list > /dev/null <<EOT
          deb http://archive.ubuntu.com/ubuntu jammy main universe
          EOT
          sudo apt-get update
          sudo apt-get --fix-broken install -y || true

          # Install required packages - use t64 variant to avoid migration conflicts
          # Remove conflicting libgtk-3-0 if present
          # sudo apt-get remove -y libgtk-3-0 2>/dev/null || true
          sudo apt-get install -y \
            libwebkit2gtk-4.1-0 \
            libgtk-3-0t64 \
            libayatana-appindicator3-1

      # Install Rust toolchain only for tauri-driver (minimal install)
      - name: ü¶Ä Setup Rust (for tauri-driver)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: üöó Install tauri-driver
        shell: bash
        run: |
          echo "Installing tauri-driver..."
          cargo install tauri-driver

      - name: üåê Install WebKit WebDriver (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          echo "Installing WebKit WebDriver for Linux..."
          sudo apt-get install -y webkit2gtk-driver
          # Verify installation
          which WebKitWebDriver || echo "WebKitWebDriver not found in PATH"
          WebKitWebDriver --version || echo "WebKitWebDriver version check failed"

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: üì¶ Download Package Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Download the pre-built Tauri E2E app binary from the OS-specific build job
      # This is much faster than rebuilding Tauri apps for each test type
      # Extract to repository root so files end up in fixtures/e2e-apps/tauri/src-tauri/target/
      - name: üì¶ Download Tauri E2E App Binary
        uses: ./.github/workflows/actions/download-archive
        with:
          name: tauri-e2e-app-${{ runner.os }}
          path: tauri-e2e-app-${{ runner.os }}
          filename: artifact.zip
          cache_key_prefix: tauri-e2e-app
          exact_cache_key: ${{ inputs.tauri_cache_key }}

      # Verify Tauri binaries were extracted correctly
      - name: ‚úÖ Verify Tauri Binaries
        shell: bash
        run: |
          echo "Checking for Tauri binaries in fixtures/e2e-apps/tauri/src-tauri/target/"

          if [ ! -d "fixtures/e2e-apps/tauri" ]; then
            echo "::error::fixtures/e2e-apps/tauri directory not found!"
            exit 1
          fi

          # Find all target directories
          TARGET_DIRS=$(find fixtures/e2e-apps/tauri -name "target" -type d 2>/dev/null || true)

          if [ -z "$TARGET_DIRS" ]; then
            echo "::error::No target directories found! Binaries were not extracted correctly."
            echo "Directory contents:"
            ls -la fixtures/e2e-apps/tauri/ || true
            ls -la fixtures/e2e-apps/tauri/src-tauri/ || true
            exit 1
          fi

          echo "‚úÖ Found target directories:"
          echo "$TARGET_DIRS"

          # Verify binaries exist
          BINARY_COUNT=0
          for target_dir in $TARGET_DIRS; do
            if [ "${{ runner.os }}" = "Windows" ]; then
              if [ -f "$target_dir/release/*.exe" ] || compgen -G "$target_dir/release/*.exe" > /dev/null; then
                BINARY_COUNT=$((BINARY_COUNT + 1))
                echo "  ‚úÖ Found Windows binary in $target_dir/release/"
              fi
            else
              # Check for executable files on Linux/Mac
              if find "$target_dir/release" -maxdepth 1 -type f -executable 2>/dev/null | grep -q .; then
                BINARY_COUNT=$((BINARY_COUNT + 1))
                echo "  ‚úÖ Found binary in $target_dir/release/"
              fi
            fi
          done

          if [ "$BINARY_COUNT" -eq 0 ]; then
            echo "::error::No binaries found in target directories!"
            exit 1
          fi

          echo "‚úÖ Verification complete: Found $BINARY_COUNT app(s) with binaries"

      # Display build information if available
      - name: üìä Show Build Information
        if: inputs.build_id != '' && inputs.artifact_size != ''
        shell: bash
        run: |
          echo "::notice::Package build: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"
          echo "::notice::Tauri binaries: Using pre-built binaries for ${{ runner.os }}"

      # Dynamically generate the Tauri test commands to run
      # Since we only have one Tauri app (basic), no module type filtering needed
      - name: ü™Ñ Generate Tauri Test Execution Plan
        id: gen-test
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const generateTauriTestCommand = (scenario, testType) => {
              return scenario
                .split(',')
                .map((s) => {
                  const scenario = s.trim();
                  const baseCommand = `test:e2e:tauri:${scenario.replace('tauri-', '')}`;
                  return testType !== 'standard'
                    ? `${baseCommand}:${testType}`
                    : baseCommand;
                })
                .join(' ');
            };
            return generateTauriTestCommand('${{ inputs.scenario }}', '${{ inputs.test-type }}');

      # Run the Tauri E2E tests directly with pnpm (bypasses Turbo's dependsOn)
      # On Linux, wrap with xvfb-run so LAUNCHER (where tauri-driver runs) has display access
      # tauri-driver launches apps during session creation, needs display in launcher context
      # This skips rebuilding Tauri apps since we downloaded pre-built binaries
      - name: üß™ Execute Tauri E2E Tests
        shell: bash
        working-directory: e2e
        env:
          # Enable Rust backtraces for debugging Tauri/GTK issues
          RUST_BACKTRACE: '1'
          # Disable AT-SPI accessibility bus warnings
          NO_AT_BRIDGE: '1'
        run: |
          if [ "${{ runner.os }}" = "Linux" ]; then
            # Use 16-bit color depth to avoid pixbuf issues with GTK/WebKit
            xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x16" \
              pnpm run ${{ steps.gen-test.outputs.result }}
          else
            pnpm run ${{ steps.gen-test.outputs.result }}
          fi

      # Show Rust debug logs
      - name: üîç Show Rust Debug Logs
        if: always()
        shell: bash
        run: |
          echo "=== Rust Debug Log ==="
          if [ -f /tmp/tauri-debug.log ]; then
            cat /tmp/tauri-debug.log
          else
            echo "No Rust debug log found at /tmp/tauri-debug.log"
          fi

          echo ""
          echo "=== Tauri App Process Info ==="
          ps aux | grep tauri || echo "No tauri processes found"

          echo ""
          echo "=== System Logs (last 50 lines) ==="
          journalctl --no-pager -n 50 || echo "No system logs available"

      # Show comprehensive debug information on failure
      - name: üêõ Debug Information
        if: always()
        shell: bash
        run: pnpm run ci:e2e:logs

      # Upload logs as artifacts on failure for later analysis
      # This helps debug issues without cluttering the GitHub Actions console
      - name: üì¶ Upload Test Logs on Failure
        if: failure()
        uses: ./.github/workflows/actions/upload-archive
        with:
          name: e2e-tauri-logs-${{ inputs.os }}-${{ inputs.scenario }}-${{ inputs.test-type }}
          output: e2e-tauri-logs-${{ inputs.os }}-${{ inputs.scenario }}-${{ inputs.test-type }}.zip
          paths: e2e/logs/**/*.log

      # Provide an interactive debugging session on failure
      # This allows manual investigation of the environment
      - name: üêõ Debug Build on Failure
        if: failure()
        uses: goosewobbler/vscode-server-action@v1.3.0
        with:
          timeout: '300000'
