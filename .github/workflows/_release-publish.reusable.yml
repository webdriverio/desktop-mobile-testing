name: Release Publish (Reusable)

on:
  workflow_call:
    inputs:
      service:
        description: 'Service to release (electron or tauri)'
        required: true
        type: string
      target_branch:
        description: 'Target branch to release from'
        required: true
        type: string
      service_version:
        description: 'New version for service packages'
        required: true
        type: string
      service_package_list:
        description: 'Comma-separated list of service packages'
        required: true
        type: string
      shared_packages_changed:
        description: 'Whether shared packages have changes'
        required: true
        type: string
      shared_package_list:
        description: 'Comma-separated list of changed shared packages'
        required: false
        type: string
      shared_version_native_utils:
        description: 'New version for native-utils'
        required: false
        type: string
      shared_version_native_utils_bump:
        description: 'Bump type for native-utils'
        required: false
        type: string
      shared_version_native_types:
        description: 'New version for native-types'
        required: false
        type: string
      shared_version_native_types_bump:
        description: 'Bump type for native-types'
        required: false
        type: string
      service_bump_type:
        description: 'Bump type for service packages'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode'
        required: false
        type: boolean
        default: false
    secrets:
      github_bot_token:
        description: 'GitHub token for authentication'
        required: true
      npm_token:
        description: 'NPM token for publishing packages'
        required: true
      deploy_key:
        description: 'SSH deploy key for pushing to the repository'
        required: true
      crates_io_token:
        description: 'Crates.io token for publishing Rust crates'
        required: false
    outputs:
      service_release_tag:
        description: 'The created service release tag'
        value: ${{ jobs.publish.outputs.service_release_tag }}
      shared_release_tags:
        description: 'Comma-separated shared package tags'
        value: ${{ jobs.publish.outputs.shared_release_tags }}

jobs:
  publish:
    runs-on: ubuntu-latest
    outputs:
      service_release_tag: ${{ steps.collect_tags.outputs.service_release_tag }}
      shared_release_tags: ${{ steps.collect_tags.outputs.shared_release_tags }}

    steps:
      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ssh-key: ${{ secrets.deploy_key }}
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.26.2

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages for ${{ inputs.service }}
        run: |
          # Build service-specific packages using Turbo's dependency resolution
          # The '...' suffix includes all dependencies automatically
          case "${{ inputs.service }}" in
            electron)
              pnpm turbo run build \
                --filter='@wdio/electron-service...' \
                --filter='@wdio/electron-cdp-bridge...' \
                --filter='@wdio/bundler...'
              ;;
            tauri)
              pnpm turbo run build \
                --filter='@wdio/tauri-service...' \
                --filter='@wdio/tauri-plugin...'
              ;;
            *)
              echo "Unknown service: ${{ inputs.service }}"
              exit 1
              ;;
          esac

      - name: Configure NPM registry
        if: ${{ !inputs.dry_run }}
        run: |
          pnpm config set registry "https://registry.npmjs.org/"
          pnpm config set //registry.npmjs.org/:_authToken ${{ secrets.npm_token }}
          pnpm whoami

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # PHASE 1: Version and publish shared packages (if changed)
      - name: Version shared packages - native-utils
        if: ${{ inputs.shared_packages_changed == 'true' && inputs.shared_version_native_utils != '' }}
        run: |
          echo "Versioning native-utils to ${{ inputs.shared_version_native_utils }}"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            pnpm package-versioner --bump ${{ inputs.shared_version_native_utils_bump }} --dry-run -t @wdio/native-utils
          else
            pnpm package-versioner --bump ${{ inputs.shared_version_native_utils_bump }} -t @wdio/native-utils
          fi

      - name: Version shared packages - native-types
        if: ${{ inputs.shared_packages_changed == 'true' && inputs.shared_version_native_types != '' }}
        run: |
          echo "Versioning native-types to ${{ inputs.shared_version_native_types }}"
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            pnpm package-versioner --bump ${{ inputs.shared_version_native_types_bump }} --dry-run -t @wdio/native-types
          else
            pnpm package-versioner --bump ${{ inputs.shared_version_native_types_bump }} -t @wdio/native-types
          fi

      # PHASE 2: Version service packages (this will update dependencies on shared packages)
      - name: Version service packages
        run: |
          echo "Versioning service packages to ${{ inputs.service_version }}"
          echo "Using bump type: ${{ inputs.service_bump_type }}"

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            pnpm package-versioner --bump ${{ inputs.service_bump_type }} --dry-run -t ${{ inputs.service_package_list }}
          else
            pnpm package-versioner --bump ${{ inputs.service_bump_type }} -t ${{ inputs.service_package_list }}
          fi

      # Publish all versioned packages to NPM
      - name: Publish to NPM
        env:
          INPUT_PACKAGE_LIST: ${{ inputs.shared_packages_changed == 'true' && format('{0},{1}', inputs.shared_package_list, inputs.service_package_list) || inputs.service_package_list }}
          INPUT_NPM_TAG: ${{ contains(inputs.service_version, '-') && 'next' || 'latest' }}
          INPUT_DRY_RUN: ${{ inputs.dry_run }}
        run: |
          pnpm tsx .github/workflows/scripts/publish-npm.ts

      # Publish Rust crate (tauri only)
      - name: Setup Rust
        if: ${{ inputs.service == 'tauri' }}
        uses: dtolnay/rust-toolchain@stable

      - name: Install GTK development libraries
        if: ${{ inputs.service == 'tauri' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libglib2.0-dev \
            libsoup2.4-dev \
            pkg-config
          # Try to install additional packages if available
          sudo apt-get install -y libwebkit2gtk-4.0-dev || echo "libwebkit2gtk-4.0-dev not available"
          sudo apt-get install -y libwebkit2gtk-4.1-dev || echo "libwebkit2gtk-4.1-dev not available"
          sudo apt-get install -y libappindicator3-dev || echo "libappindicator3-dev not available"
          sudo apt-get install -y libayatana-appindicator3-dev || echo "libayatana-appindicator3-dev not available"
          sudo apt-get install -y libsoup3-dev || echo "libsoup3-dev not available, using libsoup2.4-dev"
          # Verify pkg-config can find the libraries
          pkg-config --modversion glib-2.0
          pkg-config --modversion gio-2.0
          pkg-config --modversion libsoup-2.4

      - name: Publish to crates.io
        if: ${{ inputs.service == 'tauri' }}
        env:
          INPUT_CRATES_IO_TOKEN: ${{ secrets.crates_io_token }}
          INPUT_DRY_RUN: ${{ inputs.dry_run }}
          PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig
        run: |
          bash .github/workflows/scripts/publish-crates.sh

      # Collect all git tags created by package-versioner
      - name: Collect release tags
        id: collect_tags
        run: |
          # Get tags created by package-versioner (most recent commits)
          RECENT_TAGS=$(git tag --points-at HEAD | tr '\n' ',')

          # Identify service vs shared tags
          SERVICE_TAG=$(git tag --points-at HEAD | grep "${{ inputs.service }}-service-v" | head -n 1 || echo "")
          SHARED_TAGS=$(git tag --points-at HEAD | grep "native-" | tr '\n' ',' | sed 's/,$//')

          echo "service_release_tag=${SERVICE_TAG}" >> $GITHUB_OUTPUT
          echo "shared_release_tags=${SHARED_TAGS}" >> $GITHUB_OUTPUT

          echo "Service tag: ${SERVICE_TAG}"
          echo "Shared tags: ${SHARED_TAGS}"

      # Push tags and commits
      - name: Push tags and commits
        if: ${{ !inputs.dry_run }}
        run: |
          echo "Pushing tags and commits to ${{ inputs.target_branch }}..."
          git push --tags --no-verify
          git push origin "${{ inputs.target_branch }}" --no-verify
          echo "âœ… Successfully pushed tags and commits"

      - name: Log dry run summary
        if: ${{ inputs.dry_run }}
        run: |
          echo "========== DRY RUN SUMMARY =========="
          echo "Would have pushed the following:"
          echo "  - Branch: ${{ inputs.target_branch }}"
          echo "  - Service tag: ${{ steps.collect_tags.outputs.service_release_tag }}"
          if [ -n "${{ steps.collect_tags.outputs.shared_release_tags }}" ]; then
            echo "  - Shared tags: ${{ steps.collect_tags.outputs.shared_release_tags }}"
          fi
          echo "===================================="
