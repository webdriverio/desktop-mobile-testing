name: E2E Tests
description: 'Runs end-to-end tests across different scenarios (ESM only)'

on:
  workflow_call:
    # Make this a reusable workflow, no value needed
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows
    inputs:
      os:
        description: 'Operating system to run tests on'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use for testing'
        required: true
        type: string
      build-command:
        description: 'Build command for test applications (build or build:mac-universal)'
        type: string
        default: 'build'
      scenario:
        description: 'Test scenario (forge, builder, or no-binary)'
        required: true
        type: string
      build_id:
        description: 'Build ID from the build job'
        type: string
        required: false
      artifact_size:
        description: 'Size of the build artifact in bytes'
        type: string
        required: false
      cache_key:
        description: 'Cache key to use for downloading artifacts'
        type: string
        required: false

env:
  TURBO_TELEMETRY_DISABLED: 1
  TURBO_DAEMON: false

jobs:
  # This job runs E2E tests for a specific combination of:
  # - Operating system (Linux, Windows, macOS)
  # - Test scenario (builder, forge, no-binary)
  # - E2E tests use ESM only (CJS/ESM testing is done in package tests)
  e2e:
    name: E2E Tests
    runs-on: ${{ inputs.os }}
    strategy:
      # Continue with other tests even if one fails
      fail-fast: false
    steps:
      # Standard checkout with SSH key for private repositories
      - name: ğŸ‘· Checkout Repository
        uses: actions/checkout@v5
        with:
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Set up Node.js and PNPM using the reusable action
      - name: ğŸ› ï¸ Setup Development Environment
        uses: ./.github/workflows/actions/setup-workspace
        with:
          node-version: ${{ inputs.node-version }}

      # Download the pre-built packages from the build job
      # This ensures all tests use the same build artifacts
      - name: ğŸ“¦ Download Build Artifacts
        uses: ./.github/workflows/actions/download-archive
        with:
          name: wdio-electron-service
          path: wdio-electron-service-build
          filename: artifact.zip
          cache_key_prefix: wdio-electron-build
          exact_cache_key: ${{ inputs.cache_key || github.run_id && format('{0}-{1}-{2}-{3}{4}', 'Linux', 'wdio-electron-build', 'wdio-electron-service', github.run_id, github.run_attempt > 1 && format('-rerun{0}', github.run_attempt) || '') || '' }}

      # Display build information if available
      - name: ğŸ“Š Show Build Information
        if: inputs.build_id != '' && inputs.artifact_size != ''
        shell: bash
        run: |
          echo "::notice::Build artifact: ID=${{ inputs.build_id }}, Size=${{ inputs.artifact_size }} bytes"

      # Dynamically generate the Turbo filter for building test applications
      # This converts the scenario input into Turbo filter syntax
      - name: ğŸª„ Generate Build Filter for Test Apps
        id: gen-build
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const generateBuildFilter = (scenario) => {
              return scenario
                .split(',')
                .map((s) => `--filter=electron-${s.trim()}-e2e-app`)
                .join(' ');
            };
            return generateBuildFilter('${{ inputs.scenario }}');

      # Build the test applications using Turbo with the generated filter
      # This builds only the necessary test apps for the current test configuration
      - name: ğŸ—ï¸ Build Test Applications
        shell: bash
        run: pnpm exec turbo run ${{ inputs.build-command }} ${{ steps.gen-build.outputs.result }} --only --parallel

      # Setup protocol handlers for deeplink testing
      # Required for Windows and Linux to properly handle testapp:// protocol
      - name: ğŸ”— Setup Protocol Handlers
        if: contains(inputs.scenario, 'builder') || contains(inputs.scenario, 'forge')
        shell: bash
        run: |
          echo "=== Protocol Handler Setup ==="
          echo "Runner OS: $RUNNER_OS"
          echo "Working directory: $(pwd)"
          echo "Scenario: ${{ inputs.scenario }}"
          echo ""

          # Determine which app(s) to set up based on scenario
          APPS=()
          if [[ "${{ inputs.scenario }}" == *"builder"* ]]; then
            APPS+=("electron-builder")
          fi
          if [[ "${{ inputs.scenario }}" == *"forge"* ]]; then
            APPS+=("electron-forge")
          fi

          for APP in "${APPS[@]}"; do
            echo "Setting up protocol handler for: $APP"

            if [ "$RUNNER_OS" == "Windows" ]; then
              echo "Setting up Windows protocol handler..."

              if [ "$APP" == "electron-builder" ]; then
                echo "Checking if dist directory exists..."
                ls -la ./fixtures/e2e-apps/$APP/dist/ || echo "dist/ not found"
              else
                echo "Checking if out directory exists..."
                ls -la ./fixtures/e2e-apps/$APP/out/ || echo "out/ not found"
              fi
              echo ""

              powershell -ExecutionPolicy Bypass -File ./fixtures/e2e-apps/$APP/scripts/setup-protocol-handler.ps1
              EXIT_CODE=$?

              if [ $EXIT_CODE -ne 0 ]; then
                echo "Error: Protocol handler setup failed for $APP with exit code $EXIT_CODE"
                exit 1
              fi

            elif [ "$RUNNER_OS" == "Linux" ]; then
              echo "Setting up Linux protocol handler..."

              if [ "$APP" == "electron-builder" ]; then
                echo "Checking if dist directory exists..."
                ls -la ./fixtures/e2e-apps/$APP/dist/ || echo "dist/ not found"
              else
                echo "Checking if out directory exists..."
                ls -la ./fixtures/e2e-apps/$APP/out/ || echo "out/ not found"
              fi
              echo ""

              chmod +x ./fixtures/e2e-apps/$APP/scripts/setup-protocol-handler.sh
              ./fixtures/e2e-apps/$APP/scripts/setup-protocol-handler.sh
              EXIT_CODE=$?

              if [ $EXIT_CODE -ne 0 ]; then
                echo "Error: Protocol handler setup failed for $APP with exit code $EXIT_CODE"
                exit 1
              fi

            else
              echo "macOS: Protocol handlers are registered by the app itself via setAsDefaultProtocolClient"
              echo "No external setup needed - the app registers on first launch"
            fi

            echo ""
          done

          echo "=== Protocol Handler Setup Complete ==="

      # Dynamically generate the test commands to run
      # This handles both single and multiple scenarios
      - name: ğŸª„ Generate Test Execution Plan
        id: gen-test
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const generateTestCommand = (scenario) => {
              return scenario
                .split(',')
                .map((s) => {
                  const scenarioTrimmed = s.trim();
                  return `test:e2e:electron-${scenarioTrimmed}`;
                })
                .join(' ');
            };
            return generateTestCommand('${{ inputs.scenario }}');

      # Run the E2E tests using Turbo with the generated test commands
      # Each test builds its own apps with correct environment context
      - name: ğŸ§ª Execute E2E Tests
        shell: bash
        run: pnpm exec turbo run ${{ steps.gen-test.outputs.result }} --only --log-order=stream

      # Show logs on failure for debugging
      - name: ğŸ› Show Logs on Failure
        shell: bash
        if: failure()
        run: pnpm run ci:e2e:logs

      # Upload logs as artifacts for later analysis
      # This helps debug issues without cluttering the GitHub Actions console
      - name: ğŸ“¦ Upload Test Logs
        if: always()
        continue-on-error: true
        uses: actions/upload-artifact@v4
        with:
          name: e2e-logs-${{ inputs.os }}${{ contains(inputs.build-command, 'mac-universal') && '-u' || '' }}-${{ inputs.scenario }}
          path: e2e/logs/**/*.log
          retention-days: 90
          if-no-files-found: warn

      # Provide an interactive debugging session on failure
      # This allows manual investigation of the environment
      - name: ğŸ› Debug Build on Failure
        uses: goosewobbler/vscode-server-action@v1.3.0
        if: failure()
        with:
          timeout: '300000'
